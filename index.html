<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Racing Championship</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            color: white;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #gameCanvas {
            background: linear-gradient(45deg, #2d5a2d 0%, #4d8c4d 25%, #2d5a2d 50%, #1a4d1a 75%, #2d5a2d 100%);
            display: block;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
        }

        #speedometer {
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00ff00;
            margin-bottom: 15px;
            min-width: 150px;
        }

        #trackStatus {
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 10px;
            border: 2px solid #ff9900;
            margin-bottom: 15px;
            text-align: center;
        }

        #trackStatus.danger {
            border-color: #ff0000;
            background: rgba(50,0,0,0.8);
        }

        #minimap {
            width: 200px;
            height: 200px;
            background: rgba(0,0,0,0.8);
            border: 2px solid #00ff00;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }

        #selectionScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #00ff00;
            text-align: center;
            z-index: 200;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
        }

        #carSelection {
            display: block;
        }

        #trackSelection {
            display: none;
        }

        .selection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .option {
            padding: 15px;
            background: rgba(0,100,0,0.3);
            border: 2px solid #00ff00;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .option:hover {
            background: rgba(0,150,0,0.5);
            transform: scale(1.05);
        }

        .option.selected {
            background: rgba(0,200,0,0.6);
            border-color: #00ff88;
        }

        .car-icon {
            width: 60px;
            height: 40px;
            margin: 0 auto 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            border-radius: 5px;
        }

        .track-preview {
            width: 150px;
            height: 100px;
            margin: 0 auto 10px;
            border: 2px solid #666;
            border-radius: 5px;
            background: #333;
            position: relative;
        }

        #instructions {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00ff00;
            max-width: 250px;
        }

        .hidden {
            display: none;
        }

        #gameTitle {
            font-size: 28px;
            color: #00ff00;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #00ff00;
        }

        .continue-btn {
            background: #00ff00;
            color: black;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 20px;
        }

        .continue-btn:hover {
            background: #00cc00;
        }

        .continue-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 40px;
            border-radius: 15px;
            border: 2px solid #ff0000;
            text-align: center;
            z-index: 300;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
            text-align: left;
        }

        .restart-btn {
            background: #ff4444;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            margin: 10px;
        }

        .restart-btn:hover {
            background: #ff6666;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <div id="selectionScreen">
            <div id="carSelection">
                <h2 id="gameTitle">üèÅ RACING CHAMPIONSHIP üèÅ</h2>
                <p>Choose your car:</p>
                <div class="selection-grid" id="carGrid">
                    <!-- Cars will be populated by JavaScript -->
                </div>
                <button class="continue-btn" onclick="proceedToTrackSelection()" disabled>Continue</button>
            </div>

            <div id="trackSelection">
                <h2>üèÅ SELECT TRACK üèÅ</h2>
                <p>Choose your racing circuit:</p>
                <div class="selection-grid" id="trackGrid">
                    <!-- Tracks will be populated by JavaScript -->
                </div>
                <button class="continue-btn" onclick="startRace()" disabled>Start Race!</button>
            </div>
        </div>

        <div id="ui" class="hidden">
            <div id="speedometer">
                <div>Speed: <span id="speed">0</span> mph</div>
                <div>Gear: <span id="gear">1</span></div>
                <div>Lap: <span id="lap">1</span>/3</div>
            </div>
            <div id="trackStatus">
                <div id="statusText">Stay on track!</div>
                <div id="warningTimer"></div>
            </div>
            <div id="minimap"></div>
        </div>

        <div id="instructions" class="hidden">
            <h3>üéÆ Controls</h3>
            <p><strong>WASD</strong> - Drive</p>
            <p><strong>Shift</strong> - Boost</p>
            <p><strong>Space</strong> - Handbrake</p>
            <p><strong>R</strong> - Reset Position</p>
            <hr style="border-color: #00ff00;">
            <p>üèÅ Complete 3 laps!</p>
            <p>‚ö†Ô∏è Stay on track or get DQ'd!</p>
        </div>

        <div id="gameOver" class="hidden">
            <h2>üèÅ RACE COMPLETE üèÅ</h2>
            <div id="raceResult"></div>
            <div class="stats-grid" id="raceStats"></div>
            <button class="restart-btn" onclick="restartGame()">Race Again</button>
            <button class="restart-btn" onclick="changeTrack()" style="background: #4444ff;">Change Track</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Game state
        let gameStarted = false;
        let selectedCarType = null;
        let selectedTrack = null;
        let raceStartTime = 0;
        let currentLap = 1;
        let checkpointsPassed = [];
        let offTrackTime = 0;
        let totalOffTrackTime = 0;
        let isOffTrack = false;
        let raceFinished = false;

        // Car types with realistic slower speeds
        const carTypes = {
            hatchback: { name: 'Compact Hatchback', maxSpeed: 4, acceleration: 0.15, handling: 0.12, color: '#ff4444', emoji: 'üöó' },
            sedan: { name: 'Family Sedan', maxSpeed: 4.5, acceleration: 0.12, handling: 0.10, color: '#4444ff', emoji: 'üöô' },
            sports: { name: 'Sports Car', maxSpeed: 6, acceleration: 0.18, handling: 0.15, color: '#ff8800', emoji: 'üèéÔ∏è' },
            suv: { name: 'SUV', maxSpeed: 3.5, acceleration: 0.10, handling: 0.08, color: '#44ff44', emoji: 'üöê' },
            muscle: { name: 'Muscle Car', maxSpeed: 5.5, acceleration: 0.20, handling: 0.09, color: '#8844ff', emoji: 'üöó' },
            convertible: { name: 'Convertible', maxSpeed: 5, acceleration: 0.16, handling: 0.13, color: '#ff44ff', emoji: 'üèéÔ∏è' },
            truck: { name: 'Pickup Truck', maxSpeed: 3, acceleration: 0.08, handling: 0.06, color: '#996633', emoji: 'üõª' },
            coupe: { name: 'Luxury Coupe', maxSpeed: 5.8, acceleration: 0.17, handling: 0.14, color: '#00ffff', emoji: 'üöó' }
        };

        // Track definitions
        const tracks = {
            oval: {
                name: 'Speedway Oval',
                description: 'Classic oval track',
                trackPath: [],
                checkpoints: [],
                startX: 0,
                startY: -150,
                startAngle: 0
            },
            figure8: {
                name: 'Figure 8 Circuit',
                description: 'Challenging crossover track',
                trackPath: [],
                checkpoints: [],
                startX: -200,
                startY: 0,
                startAngle: 0
            },
            street: {
                name: 'City Street Course',
                description: 'Urban racing circuit',
                trackPath: [],
                checkpoints: [],
                startX: -180,
                startY: -100,
                startAngle: 0
            },
            mountain: {
                name: 'Mountain Pass',
                description: 'Winding mountain road',
                trackPath: [],
                checkpoints: [],
                startX: -250,
                startY: 0,
                startAngle: 0
            },
            grand_prix: {
                name: 'Grand Prix Circuit',
                description: 'Professional racing circuit',
                trackPath: [],
                checkpoints: [],
                startX: -200,
                startY: -50,
                startAngle: 0
            }
        };

        // Generate track paths
        function generateTracks() {
            // Oval track
            const ovalPoints = [];
            const ovalCheckpoints = [];
            for (let i = 0; i < 360; i += 3) {
                const angle = (i * Math.PI) / 180;
                const x = Math.cos(angle) * 300;
                const y = Math.sin(angle) * 150;
                ovalPoints.push({ x, y });
                if (i % 90 === 0) {
                    ovalCheckpoints.push({ x, y, passed: false });
                }
            }
            tracks.oval.trackPath = ovalPoints;
            tracks.oval.checkpoints = ovalCheckpoints;

            // Figure 8 track
            const fig8Points = [];
            const fig8Checkpoints = [];
            for (let i = 0; i < 360; i += 2) {
                const angle = (i * Math.PI) / 180;
                const x = Math.sin(2 * angle) * 200;
                const y = Math.sin(angle) * 150;
                fig8Points.push({ x, y });
                if (i % 90 === 0) {
                    fig8Checkpoints.push({ x, y, passed: false });
                }
            }
            tracks.figure8.trackPath = fig8Points;
            tracks.figure8.checkpoints = fig8Checkpoints;

            // Street circuit
            const streetPoints = [
                {x: -200, y: -100}, {x: 200, y: -100}, {x: 200, y: -50},
                {x: 100, y: -50}, {x: 100, y: 50}, {x: 200, y: 50},
                {x: 200, y: 100}, {x: -200, y: 100}, {x: -200, y: 50},
                {x: -100, y: 50}, {x: -100, y: -50}, {x: -200, y: -50}
            ];
            tracks.street.trackPath = streetPoints;
            tracks.street.checkpoints = [
                {x: 0, y: -100, passed: false}, {x: 200, y: 0, passed: false},
                {x: 0, y: 100, passed: false}, {x: -200, y: 0, passed: false}
            ];

            // Mountain pass
            const mountainPoints = [];
            const mountainCheckpoints = [];
            for (let i = 0; i < 720; i += 4) {
                const t = i / 720;
                const angle = t * Math.PI * 4;
                const radius = 150 + Math.sin(angle * 2) * 50;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius + t * 100 - 50;
                mountainPoints.push({ x, y });
                if (i % 180 === 0) {
                    mountainCheckpoints.push({ x, y, passed: false });
                }
            }
            tracks.mountain.trackPath = mountainPoints;
            tracks.mountain.checkpoints = mountainCheckpoints;

            // Grand Prix circuit
            const gpPoints = [
                {x: -200, y: -50}, {x: -150, y: -100}, {x: 0, y: -120},
                {x: 150, y: -100}, {x: 200, y: -50}, {x: 180, y: 0},
                {x: 200, y: 50}, {x: 150, y: 100}, {x: 0, y: 120},
                {x: -150, y: 100}, {x: -200, y: 50}, {x: -180, y: 0}
            ];
            tracks.grand_prix.trackPath = gpPoints;
            tracks.grand_prix.checkpoints = [
                {x: -75, y: -75, passed: false}, {x: 75, y: -75, passed: false},
                {x: 75, y: 75, passed: false}, {x: -75, y: 75, passed: false}
            ];
        }

        // Player car
        const car = {
            x: 0, y: 0, vx: 0, vy: 0, angle: 0, speed: 0,
            maxSpeed: 10, acceleration: 0.3, friction: 0.92,
            handling: 0.12, boosting: false, handbraking: false
        };

        // Camera
        const camera = { x: 0, y: 0 };

        // Initialize selections
        function initializeSelections() {
            const carGrid = document.getElementById('carGrid');
            const trackGrid = document.getElementById('trackGrid');

            // Populate car selection
            Object.entries(carTypes).forEach(([key, carType]) => {
                const option = document.createElement('div');
                option.className = 'option';
                option.onclick = () => selectCar(key);
                option.innerHTML = `
                    <div class="car-icon" style="background: ${carType.color};">${carType.emoji}</div>
                    <div><strong>${carType.name}</strong></div>
                    <small>Speed: ${carType.maxSpeed}/6</small><br>
                    <small>Handling: ${Math.round(carType.handling*50)}/10</small>
                `;
                option.id = `car-${key}`;
                carGrid.appendChild(option);
            });

            // Populate track selection
            Object.entries(tracks).forEach(([key, track]) => {
                const option = document.createElement('div');
                option.className = 'option';
                option.onclick = () => selectTrack(key);
                option.innerHTML = `
                    <div class="track-preview"></div>
                    <div><strong>${track.name}</strong></div>
                    <small>${track.description}</small>
                `;
                option.id = `track-${key}`;
                trackGrid.appendChild(option);
            });

            generateTracks();
        }

        function selectCar(type) {
            selectedCarType = type;
            document.querySelectorAll('.option').forEach(el => el.classList.remove('selected'));
            document.getElementById(`car-${type}`).classList.add('selected');
            document.querySelector('#carSelection .continue-btn').disabled = false;
        }

        function selectTrack(type) {
            selectedTrack = type;
            document.querySelectorAll('#trackGrid .option').forEach(el => el.classList.remove('selected'));
            document.getElementById(`track-${type}`).classList.add('selected');
            document.querySelector('#trackSelection .continue-btn').disabled = false;
        }

        function proceedToTrackSelection() {
            document.getElementById('carSelection').style.display = 'none';
            document.getElementById('trackSelection').style.display = 'block';
        }

        function startRace() {
            const carStats = carTypes[selectedCarType];
            car.maxSpeed = carStats.maxSpeed;
            car.acceleration = carStats.acceleration;
            car.handling = carStats.handling;

            const track = tracks[selectedTrack];
            car.x = track.startX;
            car.y = track.startY;
            car.angle = track.startAngle;
            car.vx = car.vy = car.speed = 0;

            // Reset race state
            currentLap = 1;
            checkpointsPassed = track.checkpoints.map(() => false);
            offTrackTime = totalOffTrackTime = 0;
            isOffTrack = raceFinished = false;
            raceStartTime = Date.now();

            document.getElementById('selectionScreen').classList.add('hidden');
            document.getElementById('ui').classList.remove('hidden');
            document.getElementById('instructions').classList.remove('hidden');

            gameStarted = true;
            gameLoop();
        }

        // Input handling
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            if (e.key.toLowerCase() === 'r') resetCarPosition();
        });
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        function resetCarPosition() {
            const track = tracks[selectedTrack];
            car.x = track.startX;
            car.y = track.startY;
            car.vx = car.vy = car.speed = 0;
            car.angle = track.startAngle;
            offTrackTime = 0;
            isOffTrack = false;
        }

        function isPointOnTrack(x, y) {
            const track = tracks[selectedTrack];
            const trackWidth = 40;
            
            let minDist = Infinity;
            for (let i = 0; i < track.trackPath.length; i++) {
                const point = track.trackPath[i];
                const dx = x - point.x;
                const dy = y - point.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                minDist = Math.min(minDist, dist);
            }
            
            return minDist <= trackWidth;
        }

        function checkCheckpoints() {
            const track = tracks[selectedTrack];
            track.checkpoints.forEach((checkpoint, index) => {
                const dx = car.x - checkpoint.x;
                const dy = car.y - checkpoint.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 30 && !checkpointsPassed[index]) {
                    checkpointsPassed[index] = true;
                    
                    // Check if all checkpoints passed
                    if (checkpointsPassed.every(passed => passed)) {
                        if (currentLap < 3) {
                            currentLap++;
                            checkpointsPassed = checkpointsPassed.map(() => false);
                        } else if (!raceFinished) {
                            finishRace(false);
                        }
                    }
                }
            });
        }

        function updateCar() {
            if (raceFinished) return;

            // Handle input
            let accelerating = false;
            car.boosting = car.handbraking = false;

            if (keys['w']) { car.speed += car.acceleration; accelerating = true; }
            if (keys['s']) car.speed -= car.acceleration * 0.7;
            if (keys['a']) car.angle -= car.handling * Math.max(0.3, Math.abs(car.speed) / car.maxSpeed);
            if (keys['d']) car.angle += car.handling * Math.max(0.3, Math.abs(car.speed) / car.maxSpeed);
            if (keys['shift']) { car.boosting = true; if (accelerating) car.speed += car.acceleration * 0.3; }
            if (keys[' ']) { car.handbraking = true; car.speed *= 0.85; }

            const maxSpeed = car.boosting ? car.maxSpeed * 1.3 : car.maxSpeed;
            car.speed = Math.max(-maxSpeed * 0.5, Math.min(maxSpeed, car.speed));

            if (!accelerating && !keys['s']) car.speed *= car.friction;

            car.vx = Math.cos(car.angle) * car.speed;
            car.vy = Math.sin(car.angle) * car.speed;
            car.x += car.vx;
            car.y += car.vy;

            // Track boundary checking
            const onTrack = isPointOnTrack(car.x, car.y);
            if (!onTrack) {
                if (!isOffTrack) {
                    isOffTrack = true;
                    offTrackTime = Date.now();
                }
                
                const timeDiff = (Date.now() - offTrackTime) / 1000;
                if (timeDiff >= 3) {
                    finishRace(true);
                    return;
                }
            } else {
                if (isOffTrack) {
                    totalOffTrackTime += (Date.now() - offTrackTime) / 1000;
                    isOffTrack = false;
                }
            }

            checkCheckpoints();

            camera.x = car.x - canvas.width / 2;
            camera.y = car.y - canvas.height / 2;
        }

        function finishRace(disqualified) {
            raceFinished = true;
            const raceTime = (Date.now() - raceStartTime) / 1000;
            
            document.getElementById('raceResult').innerHTML = disqualified 
                ? '<span style="color: #ff4444;">‚ùå DISQUALIFIED</span><br>You went off-track for too long!'
                : '<span style="color: #44ff44;">üèÜ RACE COMPLETE!</span>';
            
            document.getElementById('raceStats').innerHTML = `
                <div>Race Time:</div><div>${raceTime.toFixed(2)}s</div>
                <div>Laps:</div><div>${currentLap - (disqualified ? 1 : 0)}/3</div>
                <div>Off-Track Time:</div><div>${totalOffTrackTime.toFixed(1)}s</div>
                <div>Car:</div><div>${carTypes[selectedCarType].name}</div>
                <div>Track:</div><div>${tracks[selectedTrack].name}</div>
                <div>Max Speed:</div><div>${Math.round(Math.abs(car.speed) * 12)} mph</div>
            `;
            
            document.getElementById('gameOver').classList.remove('hidden');
        }

        function drawTrack() {
            const track = tracks[selectedTrack];
            const trackWidth = 40;
            
            // Draw track surface
            ctx.strokeStyle = '#444444';
            ctx.lineWidth = trackWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            ctx.beginPath();
            track.trackPath.forEach((point, index) => {
                const screenX = point.x - camera.x;
                const screenY = point.y - camera.y;
                if (index === 0) ctx.moveTo(screenX, screenY);
                else ctx.lineTo(screenX, screenY);
            });
            ctx.closePath();
            ctx.stroke();
            
            // Draw track borders
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw inner border
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = trackWidth - 8;
            ctx.stroke();
            
            // Draw checkpoints
            track.checkpoints.forEach((checkpoint, index) => {
                const screenX = checkpoint.x - camera.x;
                const screenY = checkpoint.y - camera.y;
                
                if (checkpointsPassed[index]) {
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.6)';
                } else {
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';
                }
                
                ctx.beginPath();
                ctx.arc(screenX, screenY, 15, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'black';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText((index + 1).toString(), screenX, screenY + 4);
            });
        }

        function drawCar() {
            const screenX = car.x - camera.x;
            const screenY = car.y - camera.y;

            ctx.save();
            ctx.translate(screenX, screenY);
            ctx.rotate(car.angle);

            const carStats = carTypes[selectedCarType];
            ctx.fillStyle = carStats.color;
            ctx.fillRect(-15, -8, 30, 16);
            
            ctx.fillStyle = '#333';
            ctx.fillRect(-12, -6, 24, 12);
            
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(-8, -4, 16, 8);
            
            // Wheels
            ctx.fillStyle = '#222';
            [-12, 6].forEach(x => [-10, 6].forEach(y => ctx.fillRect(x, y, 6, 4)));

            if (car.boosting) {
                ctx.fillStyle = 'rgba(255, 165, 0, 0.7)';
                for (let i = 0; i < 3; i++) {
                    ctx.fillRect(-20 - i * 3, -2 + (Math.random() - 0.5) * 6, 8, 4);
                }
            }

            if (car.handbraking) {
                ctx.strokeStyle = 'rgba(100, 100, 100, 0.5)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(-15, -8, 10, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(-15, 8, 10, 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.restore();
        }

        function updateUI() {
            const speedMph = Math.round(Math.abs(car.speed) * 12);
            document.getElementById('speed').textContent = speedMph;
            document.getElementById('lap').textContent = currentLap;

            let gear = Math.min(5, Math.max(1, Math.floor(speedMph / 15) + 1));
            document.getElementById('gear').textContent = gear;

            // Update track status
            const statusEl = document.getElementById('trackStatus');
            const statusText = document.getElementById('statusText');
            const warningTimer = document.getElementById('warningTimer');
            
            if (isOffTrack) {
                const timeLeft = 3 - (Date.now() - offTrackTime) / 1000;
                statusEl.className = 'danger';
                statusText.textContent = '‚ö†Ô∏è OFF TRACK!';
                warningTimer.textContent = `DQ in: ${timeLeft.toFixed(1)}s`;
            } else {
                statusEl.className = '';
                statusText.textContent = '‚úÖ On Track';
                warningTimer.textContent = '';
            }

            // Update minimap
            updateMinimap();
        }

        function updateMinimap() {
            const minimap = document.getElementById('minimap');
            minimap.innerHTML = '';

            const minimapCanvas = document.createElement('canvas');
            minimapCanvas.width = 200;
            minimapCanvas.height = 200;
            const minimapCtx = minimapCanvas.getContext('2d');

            minimapCtx.fillStyle = '#1a4d1a';
            minimapCtx.fillRect(0, 0, 200, 200);

            const track = tracks[selectedTrack];
            const scale = 0.4;
            const centerX = 100;
            const centerY = 100;

            // Draw track on minimap
            minimapCtx.strokeStyle = '#666';
            minimapCtx.lineWidth = 8;
            minimapCtx.beginPath();
            track.trackPath.forEach((point, index) => {
                const mapX = centerX + (point.x - car.x) * scale;
                const mapY = centerY + (point.y - car.y) * scale;
                if (index === 0) minimapCtx.moveTo(mapX, mapY);
                else minimapCtx.lineTo(mapX, mapY);
            });
            minimapCtx.closePath();
            minimapCtx.stroke();

            // Draw checkpoints on minimap
            track.checkpoints.forEach((checkpoint, index) => {
                const mapX = centerX + (checkpoint.x - car.x) * scale;
                const mapY = centerY + (checkpoint.y - car.y) * scale;
                
                if (mapX >= 0 && mapX <= 200 && mapY >= 0 && mapY <= 200) {
                    minimapCtx.fillStyle = checkpointsPassed[index] ? '#00ff00' : '#ffff00';
                    minimapCtx.beginPath();
                    minimapCtx.arc(mapX, mapY, 4, 0, Math.PI * 2);
                    minimapCtx.fill();
                }
            });

            // Draw car on minimap
            minimapCtx.fillStyle = carTypes[selectedCarType].color;
            minimapCtx.save();
            minimapCtx.translate(centerX, centerY);
            minimapCtx.rotate(car.angle);
            minimapCtx.fillRect(-4, -2, 8, 4);
            minimapCtx.restore();

            // Draw direction indicator
            minimapCtx.strokeStyle = '#ffffff';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.moveTo(centerX, centerY - 10);
            minimapCtx.lineTo(centerX - 5, centerY - 5);
            minimapCtx.moveTo(centerX, centerY - 10);
            minimapCtx.lineTo(centerX + 5, centerY - 5);
            minimapCtx.stroke();

            minimap.appendChild(minimapCanvas);
        }

        function gameLoop() {
            if (!gameStarted || raceFinished) return;

            updateCar();

            // Clear canvas with grass background
            const gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, Math.max(canvas.width, canvas.height));
            gradient.addColorStop(0, '#4d8c4d');
            gradient.addColorStop(1, '#2d5a2d');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grass texture grid
            ctx.strokeStyle = 'rgba(0,0,0,0.1)';
            ctx.lineWidth = 1;
            const gridSize = 50;
            const startX = -(camera.x % gridSize);
            const startY = -(camera.y % gridSize);

            for (let x = startX; x < canvas.width + gridSize; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }

            for (let y = startY; y < canvas.height + gridSize; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            drawTrack();
            drawCar();
            updateUI();

            requestAnimationFrame(gameLoop);
        }

        function restartGame() {
            document.getElementById('gameOver').classList.add('hidden');
            startRace();
        }

        function changeTrack() {
            gameStarted = false;
            raceFinished = false;
            
            document.getElementById('gameOver').classList.add('hidden');
            document.getElementById('ui').classList.add('hidden');
            document.getElementById('instructions').classList.add('hidden');
            
            document.getElementById('selectionScreen').classList.remove('hidden');
            document.getElementById('carSelection').style.display = 'none';
            document.getElementById('trackSelection').style.display = 'block';
            
            // Reset track selection
            document.querySelectorAll('#trackGrid .option').forEach(el => el.classList.remove('selected'));
            document.querySelector('#trackSelection .continue-btn').disabled = true;
            selectedTrack = null;
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Prevent context menu
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // Initialize the game
        initializeSelections();
    </script>
</body>
</html>
